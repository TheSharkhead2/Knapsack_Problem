"""
Dynamic programming algorithm to solve the bounded knapsack problem

"""
function bounded_dp_knapsack(situation::Situation)
    # Array to store all score values for each combination of a number of things, a thing, and a weight. nk x W array
    scores = Int.(zeros((length(situation.things) * situation.maxNThings)+1, situation.maxWeight+1))

    for w in 1:situation.maxWeight # loop through all the possible weights 
        for (thingIndex, thing) in enumerate(situation.things) # loop through all the things 
            for k in 1:situation.maxNThings # loop through all the possible quantities of things 
                if (k * thing.weight > w) || (k > thing.maxN) # if the k Things can't fit into the knapsack OR k is greater than the number of available things (by just setting it to the previous value in this instance, because of the way we calculate what Things are taken, this k value is ignored)
                    scores[((thingIndex-1)*situation.maxNThings)+k+1, w+1] = scores[(thingIndex-1)*situation.maxNThings+k, w+1] # then score of this cell is simply the score of the cell directly above it (so either the previous number of Things for this same Thing or the last Thing and the max number of Things)
                else # if the k Things can fit into the knapsack
                    scores[((thingIndex-1)*situation.maxNThings+k)+1, w+1] = maximum([scores[((thingIndex-1)*situation.maxNThings+k), w+1], (scores[((thingIndex-1)*situation.maxNThings)+1, w-thing.weight*k+1] + thing.value*k)]) # otherwise, the score is the maximum of the cell directly above this one and the last weight step plus this Thing's value
                end # if
            end # for 
        end #for 
    end # for 

    scores[size(scores)[1], size(scores)[2]] #, get_best_things(scores, situation)
end # function bounded_dp_knapsack

"""
Function that takes the matrix generated by bounded_dp_knapsack and returns
the best Things combination.

"""
function get_best_things(values::Matrix{Int64}, situation::Situation)
    totals = Int.(zeros(length(situation.things))) # blank Vector to store the counts for all the Things

    i, j = size(values)[1], size(values)[2] # get the starting index for the loop (the maximum value) as the bottom right corner of the matrix

    while i != 1 # continue the loop until we reach the Thing row of 0 (not representing a Thing)
        if values[i, j] == values[i-1, j] # if the value at the current index is the same as the value at the previous index
            i = i - 1 # then we need to go up one row
        else # if the value at the current index is different from the value at the previous index
            k = (i-1) % situation.maxNThings # get the current number of things for this index (except when k=maxK, then this k=0)

            thingIndex = Int(((i-1)-k)/situation.maxNThings + 1) # get the thing index 
            
            if k == 0
                k = situation.maxNThings # if k == 0, then the actual number of Things is the max 
            end # if 

            totals[thingIndex] += k # add the number of Things to the totals Vector
            
            # go to weight class previous 
            i = Int(((i-1)-k)/situation.maxNThings)*situation.maxNThings + 1 # get Thing index representing the max k times the previous Thing 
            j = Int(j - k*situation.things[thingIndex].weight) # go to the previous weight column

        end # if
    end # while 
    
    totals 

end # function get_best_things

"""
DEPRECATED -- DOESN'T WORK

Function to find the ideal items to put into the Knapsack in the knapsack
problem. Implemented with a sudo-dynamic programming solution that doesn't 
work.  

"""
function get_best_items(situation::Situation)
    # matrix to store all of the values for each item and weight. 
    scores = Int.(zeros(length(situation.things)+1, situation.maxWeight+1))

    blankTuple = Tuple(Int.(zeros(length(situation.things)))) # blank tuple to fill matrix with which counts number of each item at each index

    thingTotals = fill(blankTuple, (length(situation.things)+1, situation.maxWeight+1)) # matrix of the same size with a bunch of tuples counting the number of each item at each position. Currently all 0 to initialize matrix

    for w in 1:situation.maxWeight # loop through all the possible weights in the situation
        for (thingIndex, thing) in enumerate(situation.things) # loop through all the things 
            if w-thing.weight >= 0 # make sure you can fit thing into knapsack 
                previousValues = scores[1:length(situation.things)+1, w-thing.weight+1] # get all the values from the weight when "removing" this thing 

                newTotals = getfield.(thingTotals[1:length(situation.things)+1, w-thing.weight+1], thingIndex) .+ 1
                totalsDifferences = newTotals .- thing.maxN
                previousValuesOver = totalsDifferences .< 0

                previousValuesIncreased = previousValues + (previousValuesOver * thing.value) # add the value of the thing to the previous values if there are enough of the thing

                # get the max value of the values 
                maxValue = findmax(previousValuesIncreased) # get maximum value and its index

                if previousValuesOver[maxValue[2]] == 1 # if you could fit another thing in and so we are adding a thing, then make sure that is updated 
                    scores[thingIndex+1, w+1] = maxValue[1] # set the value at this index to the maximum value of the previous values added to the things value
                    
                    previousTotals = thingTotals[maxValue[2], w-thing.weight+1]

                    thingTotals[thingIndex+1, w+1] = (previousTotals[1:thingIndex-1]..., previousTotals[thingIndex]+1, previousTotals[thingIndex+1:length(previousTotals)]...)
                else # otherwise you don't have to update the thingTotals
                    scores[thingIndex+1, w+1] = maxValue[1] # set the value of the thing at this weight to the max value (so the previous best)

                    thingTotals[thingIndex+1, w+1] = thingTotals[maxValue[2], w-thing.weight+1] # set the thingTotals to the thingTotals of the previous weight (nothing was updated)
                end # if
            end # if 
        end # for
    end # for

    maxScore = findmax(scores[1:length(situation.things)+1, situation.maxWeight+1]) # get the max value and index of the last row of scores (this would be the ideal score)

    thingComb = thingTotals[maxScore[2], situation.maxWeight+1] # get the thing combination of the max score

    (maxScore[1], thingComb)

end # function get_best_items

